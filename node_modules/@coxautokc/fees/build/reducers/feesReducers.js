"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.feesReducers = exports.initialState = exports.initialQuoteFee = undefined;

var _actionTypes = require("../actions/actionTypes");

var types = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var initialQuoteFee = exports.initialQuoteFee = {
  feeId: 0,
  feeCategory: "",
  feeCategoryId: 0,
  feeType: "",
  feeTypeId: 0,
  state: "",
  feeCustomName: "",
  capitalizedIndicator: false,
  feeAmount: "",
  paidTo: ""
};

var initialState = exports.initialState = {
  error: {
    "Fee Type": false,
    "Fee Name": false,
    Amount: false,
    "Paid To Code": false
  },
  formHasError: false,
  fees: [],
  grouppedFees: {},
  quoteFees: [initialQuoteFee],
  savedQuoteFees: []
};

var feesReducers = exports.feesReducers = function feesReducers() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  var action = arguments[1];

  switch (action.type) {
    case types.FETCH_EXISTING_FEE_QUOTE_FEE_SUCCESS:
      var grouppedFees = {};
      var fees = action.payload.fees;
      var existingQuoteFees = action.payload.quoteFees;
      for (var i = 0; i < fees.length; i++) {
        if (!grouppedFees[fees[i]["feeCategory"]]) {
          grouppedFees[fees[i]["feeCategory"]] = [];
        }
        grouppedFees[fees[i]["feeCategory"]].push(fees[i]);
      }

      var quoteFees = existingQuoteFees.map(function (qf) {
        return Object.assign({}, qf, {
          feeAmount: qf["feeAmount"].toString()
        }, {
          feeId: 1001,
          feeCategory: "Dealer Fees",
          feeCategoryId: 1,
          feeType: "Documentation Fee",
          feeTypeId: 5,
          state: "NY"
        });
      });

      return Object.assign({}, state, {
        grouppedFees: grouppedFees,
        quoteFees: quoteFees.concat(state.quoteFees),
        savedQuoteFees: quoteFees.concat(state.quoteFees),
        fees: fees
      });

    case types.HANDLE_CHANGE_FROM_FORM:
      {
        var value = action.payload.value;
        var name = action.payload.name;
        var attr = action.payload.attr;
        var idInfo = name.split("-");
        var index = Number(idInfo[idInfo.length - 1]);
        var tmp = {};
        if (attr === "feeType") {
          var feeId = Number(value);
          tmp = Object.assign({}, state.fees.find(function (fee) {
            return feeId === fee.feeId;
          }));
          tmp["feeCustomName"] = tmp["feeType"];
        } else {
          tmp[attr] = value;
        }

        return Object.assign({}, state, {
          quoteFees: state.quoteFees.map(function (quoteFee, idx) {
            return idx === index ? Object.assign({}, quoteFee, tmp) : quoteFee;
          })
        });
      }

    case types.HANDLE_CHANGE_FROM_INPUT:
      {
        var _value = action.payload.value;
        var _name = action.payload.name;
        var _idInfo = _name.split("-");
        var _index = Number(_idInfo[_idInfo.length - 1]);
        return Object.assign({}, state, {
          quoteFees: state.quoteFees.map(function (quoteFee, idx) {
            return idx === _index ? Object.assign({}, quoteFee, { feeAmount: _value }) : quoteFee;
          })
        });
      }

    case types.HANDLE_BLUR_FROM_INPUT:
      {
        var _value2 = action.payload.value;
        var _name2 = action.payload.name;
        var _idInfo2 = _name2.split("-");
        var _index2 = Number(_idInfo2[_idInfo2.length - 1]);
        // change value from input to "1,000,000.00" format
        var _tmp = parseFloat(_value2.replace(/,/g, "")).toFixed(2).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");

        _tmp === "NaN" && (_tmp = "");

        return Object.assign({}, state, {
          quoteFees: state.quoteFees.map(function (quoteFee, idx) {
            return idx === _index2 ? Object.assign({}, quoteFee, { feeAmount: _tmp }) : quoteFee;
          })
        });
      }

    case types.DELETE_FEE:
      return Object.assign({}, state, {
        quoteFees: state.quoteFees.filter(function (quoteFee, idx) {
          return idx !== action.payload.index;
        })
      });

    case types.APPEND_FEE:
      return Object.assign({}, state, {
        quoteFees: [].concat(_toConsumableArray(state.quoteFees), [initialQuoteFee])
      });

    case types.REFRESH_FORM:
      return Object.assign({}, state, {
        quoteFees: [initialQuoteFee],
        error: {
          "Fee Type": false,
          "Fee Name": false,
          Amount: false,
          "Paid To Code": false
        },
        formHasError: false
      });

    case types.CANCEL_EDITING:
      return Object.assign({}, state, {
        quoteFees: state.savedQuoteFees
      });

    case types.VALIDATE_QUOTE_FEES:
      return Object.assign({}, state, {
        error: action.payload.error,
        formHasError: action.payload.formHasError
      });

    case types.SAVE_QUOTE_FEES:
      var cleanedQuoteFees = state["quoteFees"].filter(function (fee) {
        return fee.feeType.length || fee.feeCustomName.length || fee.feeAmount.length || fee.paidTo.length;
      });

      return Object.assign({}, state, {
        quoteFees: cleanedQuoteFees.concat(initialQuoteFee),
        savedQuoteFees: cleanedQuoteFees.concat(initialQuoteFee)
      });

    default:
      return state;
  }
};