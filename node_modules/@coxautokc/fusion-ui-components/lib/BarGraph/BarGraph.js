'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _d = require('d3');

var _d2 = _interopRequireDefault(_d);

var _Axis = require('../internal/Axis');

var _Axis2 = _interopRequireDefault(_Axis);

var _AxisLabel = require('../internal/AxisLabel');

var _AxisLabel2 = _interopRequireDefault(_AxisLabel);

var _Grid = require('../internal/Grid');

var _Grid2 = _interopRequireDefault(_Grid);

var _Tooltip = require('../internal/Tooltip');

var _Tooltip2 = _interopRequireDefault(_Tooltip);

var _Legend = require('../internal/Legend');

var _Legend2 = _interopRequireDefault(_Legend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** Bar Chart */
var BarGraph = function (_React$Component) {
  _inherits(BarGraph, _React$Component);

  function BarGraph(props) {
    _classCallCheck(this, BarGraph);

    var _this = _possibleConstructorReturn(this, (BarGraph.__proto__ || Object.getPrototypeOf(BarGraph)).call(this, props));

    _this.updateSize = function () {
      var node = _reactDom2.default.findDOMNode(_this);
      var parentWidth = node.offsetWidth;
      parentWidth < _this.props.width ? _this.setState({ width: parentWidth }) : _this.setState({ width: _this.props.width });
    };

    _this.showToolTip = function (e) {
      var pointColor = e.target.getAttribute('fill');
      e.target.setAttribute('fill', '#6f8679');
      _this.setState({
        tooltip: {
          display: true,
          orientation: 'horizontal',
          data: {
            key: e.target.getAttribute('data-key'),
            value: e.target.getAttribute('data-value')
          },
          pos: {
            x: parseInt(e.target.getAttribute('x'), 10),
            y: parseInt(e.target.getAttribute('y'), 10),
            width: parseInt(e.target.getAttribute("width"), 10)
          }
        },
        dataPointColor: pointColor
      });
    };

    _this.hideToolTip = function (e) {
      e.target.setAttribute('fill', _this.state.dataPointColor);
      _this.setState({
        tooltip: {
          display: false,
          data: {
            key: '',
            value: ''
          },
          pos: {
            x: 0,
            y: 0
          }
        },
        dataPointColor: ''
      });
    };

    _this.state = {
      tooltip: {
        display: false,
        data: {
          key: '',
          value: ''
        },
        pos: {
          x: 0,
          y: 0
        }
      },
      width: _this.props.width,
      height: _this.props.height,
      data: []
    };
    return _this;
  }

  _createClass(BarGraph, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      window.addEventListener('resize', this.updateSize, false);
      this.setState({ width: this.props.width });
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.reloadBarData();
      this.repaintComponent();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.removeEventListener('resize', this.updateSize, false);
    }
  }, {
    key: 'repaintComponent',
    value: function repaintComponent() {
      var forceResize = this.updateSize;
      function onRepaint(callback) {
        setTimeout(function () {
          window.requestAnimationFrame(callback);
        }, 0);
      }
      onRepaint(forceResize);
    }
  }, {
    key: 'stackType',
    value: function stackType() {
      var tempArray = [];
      if (typeof this.props.yMax === "number") {
        tempArray.push(this.props.yMax);
      } else {
        var d = this.stacked;
        for (var i in d) {
          for (var j in d[i]) {
            if (this.props.barChartType === "side") {
              tempArray.push(d[i][j].y);
            } else {
              tempArray.push(d[i][j].y + d[i][j].y0);
            }
          }
        }
      }
      return tempArray;
    }
  }, {
    key: 'createChart',
    value: function createChart(_self) {
      if (this.props.colors) {
        this.color = _d2.default.scale.ordinal().range(this.props.colors);
      } else {
        this.color = _d2.default.scale.category10();
      }

      var xLabelHeightOffset = this.props.xAxisLabel ? 30 : 0;
      var yLabelWidthOffset = this.props.yAxisLabel ? 20 : 0;
      yLabelWidthOffset = this.props.displayYAxisAsPercent ? yLabelWidthOffset + 20 : yLabelWidthOffset;

      // Width of graph
      this.w = this.state.width - (this.props.margin.left + this.props.margin.right + yLabelWidthOffset);

      // Height of graph
      this.h = this.props.height - (this.props.margin.top + this.props.margin.bottom + xLabelHeightOffset);

      this.stacked = _d2.default.layout.stack()(_self.props.keys.map(function (key) {
        return _self.state.data.map(function (d) {
          return { x: d[_self.props.xDataKey], y: d[key] };
        });
      }));

      // X0 axis scale
      this.x0Scale = _d2.default.scale.ordinal().rangeRoundBands([0, this.w], this.props.groupSpacing).domain(this.stacked[0].map(function (d) {
        return d.x;
      }));

      // X1 axis scale
      this.x1Scale = _d2.default.scale.ordinal().rangeRoundBands([0, this.x0Scale.rangeBand()], this.props.individualSpacing).domain(this.props.keys.map(function (d) {
        return d;
      }));

      // Y axis scale
      this.yScale = _d2.default.scale.linear().rangeRound([this.h, 0]).domain([0, _d2.default.max(this.stackType())]).nice();

      if (this.props.displayYAxisAsPercent) {
        this.yAxis = _d2.default.svg.axis().scale(this.yScale).orient('left').tickFormat(function (x) {
          return x + '%';
        }).ticks(5);
      } else {
        this.yAxis = _d2.default.svg.axis().scale(this.yScale).orient('left').ticks(5);
      }

      this.xAxis = _d2.default.svg.axis().scale(this.x0Scale).orient('bottom').ticks(this.state.data.length);

      this.yGrid = _d2.default.svg.axis().scale(this.yScale).orient('left').ticks(5).tickSize(-this.w, 0, 0).tickFormat("");

      this.transform = 'translate(' + (this.props.margin.left + yLabelWidthOffset) + ',' + this.props.margin.top + ')';
    }
  }, {
    key: 'reloadBarData',
    value: function reloadBarData() {
      var data = this.props.data;
      this.setState({ data: data });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      this.createChart(this);

      var _state = this.state,
          width = _state.width,
          tooltip = _state.tooltip;
      var _props = this.props,
          barChartType = _props.barChartType,
          legendValues = _props.legendValues,
          className = _props.className,
          keys = _props.keys,
          displayLegend = _props.displayLegend,
          title = _props.title,
          htmlId = _props.htmlId,
          height = _props.height,
          xAxisLabel = _props.xAxisLabel,
          yAxisLabel = _props.yAxisLabel,
          displayYAxisAsPercent = _props.displayYAxisAsPercent,
          tooltipBgColor = _props.tooltipBgColor,
          margin = _props.margin,
          xToolTipLabel = _props.xToolTipLabel,
          yToolTipLabel = _props.yToolTipLabel,
          labelKey = _props.labelKey;


      var bars = this.stacked.map(function (data, i) {
        var rects = void 0;
        if (barChartType === "side") {
          rects = data.map(function (d, j) {
            return _react2.default.createElement('rect', {
              x: _this2.x0Scale(d.x) + i * (_this2.x0Scale.rangeBand() / _this2.stacked.length),
              y: _this2.h - (_this2.yScale(d.y0) - _this2.yScale(d.y + d.y0)),
              fill: _this2.color(i),
              onMouseOver: _this2.showToolTip,
              onMouseOut: _this2.hideToolTip,
              height: _this2.yScale(d.y0) - _this2.yScale(d.y + d.y0),
              width: _this2.x1Scale.rangeBand(),
              'data-key': legendValues[i],
              'data-value': d.y,
              key: j
            });
          });
        } else {
          rects = data.map(function (d, j) {
            return _react2.default.createElement(
              'g',
              { key: j },
              _react2.default.createElement('rect', {
                x: _this2.x0Scale(d.x),
                y: _this2.yScale(d.y + d.y0),
                fill: _this2.color(i),
                onMouseOver: _this2.showToolTip,
                onMouseOut: _this2.hideToolTip,
                height: _this2.yScale(d.y0) - _this2.yScale(d.y + d.y0),
                width: _this2.x0Scale.rangeBand(),
                'data-key': legendValues[i],
                'data-value': d.y })
            );
          });
        }

        return _react2.default.createElement(
          'g',
          { key: i },
          rects
        );
      });

      var customClassName = "";

      if (className) {
        customClassName = " " + className;
      }

      var legend = [];
      var legendType = legendValues ? legendValues : keys;

      if (displayLegend) {
        legendType.forEach(function (value, i) {
          var legendObj = {};
          legendObj["label"] = value;
          legend[i] = legendObj;
        });
      }

      return _react2.default.createElement(
        'div',
        null,
        title && _react2.default.createElement(
          'h3',
          null,
          title
        ),
        _react2.default.createElement(
          'svg',
          { className: "rd3r-chart rd3r-bar-graph" + customClassName, id: htmlId, width: width, height: height },
          _react2.default.createElement(
            'g',
            { transform: this.transform },
            _react2.default.createElement(_Grid2.default, { h: this.h, grid: this.yGrid, gridType: 'y' }),
            _react2.default.createElement(_Axis2.default, { h: this.h, axis: this.yAxis, axisType: 'y' }),
            _react2.default.createElement(_Axis2.default, { h: this.h, axis: this.xAxis, axisType: 'x' }),
            xAxisLabel && _react2.default.createElement(_AxisLabel2.default, { key: 0, h: this.h, w: this.w, axisLabel: xAxisLabel, axisType: 'x' }),
            yAxisLabel && _react2.default.createElement(_AxisLabel2.default, { key: 1, h: this.h, w: this.w, axisLabel: yAxisLabel, axisType: 'y', padding: displayYAxisAsPercent ? 15 : 0 }),
            bars,
            _react2.default.createElement(_Tooltip2.default, {
              tooltip: tooltip,
              bgStyle: tooltipBgColor,
              chartWidth: width,
              chartHeight: this.state.height,
              margin: margin,
              xAxis: xAxisLabel ? true : false,
              xValue: xToolTipLabel,
              yValue: yToolTipLabel
            })
          )
        ),
        displayLegend && _react2.default.createElement(_Legend2.default, { data: legend, labelKey: labelKey, colors: this.color })
      );
    }
  }]);

  return BarGraph;
}(_react2.default.Component);

BarGraph.propTypes = {
  /** Chart type of stack or side by side. */
  barChartType: _propTypes2.default.oneOf(['stack', 'side']),

  /** Adds additional class name(s). */
  className: _propTypes2.default.string,

  /** Override colors for rectangle fill e.g. <code>["#084b62", "yellow", "#ab264b"]</code>. The number of colors should match the number of data series. */
  colors: _propTypes2.default.array,

  /** Data to be graphed. */
  data: _propTypes2.default.array.isRequired,

  /** Display legend. */
  displayLegend: _propTypes2.default.bool,

  /** Display Y Axis as percentage. */
  displayYAxisAsPercent: _propTypes2.default.bool,

  /** Space between groups of bars based on percentage of width of chart. Values between 1 and 0.  */
  groupSpacing: _propTypes2.default.number,

  /** Graph height. */
  height: _propTypes2.default.number,

  /** Globally unique and descriptive HTML ID. Used by QA for automated testing. */
  htmlId: _propTypes2.default.string.isRequired,

  /** Space between individual bars based on percentage of width of group. Values between 1 and 0.  */
  individualSpacing: _propTypes2.default.number,

  /** Keys for key-value pair of values to be graphed. */
  keys: _propTypes2.default.array.isRequired,

  /** Label key-value pair key value in data. */
  labelKey: _propTypes2.default.string,

  /** Override values for legend. It will display in order of array. If not set the key-value from the key-value pair will be used. */
  legendValues: _propTypes2.default.array,

  /** Margin for graph area. */
  margin: _propTypes2.default.object,

  /** Graph title. */
  title: _propTypes2.default.string,

  /** Tooltip background color. */
  tooltipBgColor: _propTypes2.default.string,

  /** Graph max-width. */
  width: _propTypes2.default.number,

  /** X Axis label. */
  xAxisLabel: _propTypes2.default.string,

  /** X Axis column group label to appear below individual column. */
  xDataKey: _propTypes2.default.string.isRequired,

  /** X Axis tooltip label. */
  xToolTipLabel: _propTypes2.default.string,

  /** Y Axis label. */
  yAxisLabel: _propTypes2.default.string,

  /** Set Y maximum value to be displayed. */
  yMax: _propTypes2.default.number,

  /** Y Axis tooltip label. */
  yToolTipLabel: _propTypes2.default.string
};

BarGraph.defaultProps = {
  width: 1920,
  height: 400,
  barChartType: "stack",
  groupSpacing: .3,
  individualSpacing: .5,
  xToolTipLabel: '',
  yToolTipLabel: '',
  legendValues: [],
  displayYAxisAsPercent: false,
  displayLegend: true,
  margin: {
    top: 10,
    right: 40,
    bottom: 30,
    left: 40
  }
};

exports.default = BarGraph;