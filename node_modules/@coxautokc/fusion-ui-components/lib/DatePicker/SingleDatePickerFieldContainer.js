'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _arrayIncludes = require('array-includes');

var _arrayIncludes2 = _interopRequireDefault(_arrayIncludes);

var _isInclusivelyAfterDay = require('react-dates/lib/utils/isInclusivelyAfterDay');

var _isInclusivelyAfterDay2 = _interopRequireDefault(_isInclusivelyAfterDay);

var _isSameDay = require('react-dates/lib/utils/isSameDay');

var _isSameDay2 = _interopRequireDefault(_isSameDay);

var _SingleDatePickerShape = require('react-dates/lib/shapes/SingleDatePickerShape');

var _SingleDatePickerShape2 = _interopRequireDefault(_SingleDatePickerShape);

var _constants = require('react-dates/constants');

var _SingleDatePickerField = require('./SingleDatePickerField');

var _SingleDatePickerField2 = _interopRequireDefault(_SingleDatePickerField);

var _SingleDatePicker = require('./SingleDatePicker');

var _SingleDatePicker2 = _interopRequireDefault(_SingleDatePicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// util functions from 'react-dates'


// Shapes


// Constants


var SingleDatePickerFieldContainer = function (_Component) {
  _inherits(SingleDatePickerFieldContainer, _Component);

  function SingleDatePickerFieldContainer(props) {
    _classCallCheck(this, SingleDatePickerFieldContainer);

    var _this = _possibleConstructorReturn(this, (SingleDatePickerFieldContainer.__proto__ || Object.getPrototypeOf(SingleDatePickerFieldContainer)).call(this, props));

    _this.componentDidMount = function () {
      _this.props.onDateChange(_this.createReturnedEvent(_this.state.dateString), _this.state.error.length === 0);
    };

    _this.didInteractWithField = function () {
      return !!_this.props.error;
    };

    _this.today = function () {
      return (0, _moment2.default)();
    };

    _this.getModifiers = function () {
      var modifiers = {
        today: function today(day) {
          return _this.isToday(day);
        },
        blocked: function blocked(day) {
          return _this.isBlocked(day);
        },
        'blocked-calendar': function blockedCalendar(day) {
          return _this.props.isDayBlocked(day);
        },
        'blocked-out-of-range': function blockedOutOfRange(day) {
          return _this.isOutsideRange(day);
        },
        'highlighted-calendar': function highlightedCalendar(day) {
          return _this.props.isDayHighlighted(day);
        },
        valid: function valid(day) {
          return !_this.isBlocked(day);
        },
        hovered: function hovered(day) {
          return _this.isHovered(day);
        },
        selected: function selected(day) {
          return _this.isSelected(day);
        }
      };
      return modifiers;
    };

    _this.isToday = function (day) {
      return (0, _isSameDay2.default)(day, _this.today());
    };

    _this.isBlocked = function (day) {
      return _this.props.isDayBlocked(day) || _this.isOutsideRange(day);
    };

    _this.isHovered = function (day) {
      return (0, _isSameDay2.default)(day, _this.state.hoverDate);
    };

    _this.isSelected = function (day) {
      return (0, _isSameDay2.default)(day, (0, _moment2.default)(_this.state.dateString));
    };

    _this.isOutsideRange = function (day) {
      if (_this.props.restrictOutsideDays) {
        return _this.props.isOutsideRange(day);
      }
    };

    _this.getDateString = function (date) {
      if ((0, _moment2.default)(date).isValid()) {
        return (0, _moment2.default)(date).format(_this.props.textFieldFormat);
      } else {
        return date;
      }
    };

    _this.isStrictlyFormattedDateString = function (date) {
      return (0, _moment2.default)(date, _this.props.textFieldFormat).isValid();
    };

    _this.onDayMouseEnter = function (day) {
      _this.setState({
        hoverDate: day
      });
    };

    _this.onDayMouseLeave = function () {
      _this.setState({
        hoverDate: null
      });
    };

    _this.onOutsideClick = function () {
      // Check to ensure the datePicker has been interacted with
      if (!_this.state.showDatePicker) return;
      _this.onClearFocus();
    };

    _this.onDayClick = function (day, e) {
      if (e) e.preventDefault();
      if (_this.isBlocked(day)) return;

      var dateString = _this.getDateString(day);

      _this.setState({
        day: day,
        dateString: dateString,
        error: _this.getErrorMsg(dateString),
        warning: ''
      }, function () {
        _this.props.onDateChange(_this.createReturnedEvent(_this.formatReturnedDate(day)), true);
        !_this.props.keepOpenOnDateSelect && _this.onClearFocus();
      });
    };

    _this.getInitialVisibleMonth = function () {
      return _this.isValidDateString(_this.state.dateString) ? function () {
        return (0, _moment2.default)(_this.state.dateString);
      } : function () {
        return (0, _moment2.default)();
      };
    };

    _this.toggleInputButton = function () {
      _this.setState(function (prevState) {
        return { showDatePicker: !prevState.showDatePicker };
      });
    };

    _this.onFocus = function () {
      if (!_this.props.disabled) {
        _this.setState({
          showDatePicker: true
        });
      }
    };

    _this.onClearFocus = function () {
      var dateString = _this.state.dateString;
      var selectedDate = _this.props.selectedDate;

      _this.didInteractWithField = true;

      var isValidDate = _this.isValidDateString(dateString);
      var reformattedDateString = isValidDate ? _this.getDateString(dateString) : dateString;
      var valueIsSame = selectedDate === dateString || _this.getDateString(selectedDate) === dateString;

      var warning = _this.state.warning && valueIsSame ? _this.state.warning : '';
      var error = warning ? '' : _this.getErrorMsg(reformattedDateString);

      _this.setState({
        error: error,
        dateString: reformattedDateString,
        showDatePicker: false,
        warning: warning
      });
    };

    _this.getWarningMsg = function (date) {
      var overrideError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!_this.isTextFieldEmpty(date)) {
        if (!_this.isStrictlyFormattedDateString(date)) return 'Received an Invalid Date Format (' + _this.props.textFieldFormat.toLowerCase() + ')';
        if (_this.isBlocked((0, _moment2.default)(date))) return 'Received an Unavailable Date';
        return '';
      } else {
        if (overrideError && _this.props.required) return 'Received Empty Value on Required Field';
        return '';
      }
    };

    _this.getErrorMsg = function (date, passedDate) {
      if (!_this.didInteractWithField || passedDate) return '';
      if (_this.props.error && _this.props.error.length > 0) return _this.props.error;
      if (_this.isTextFieldEmpty(date) && _this.props.required) return 'This Field is Required';
      if (_this.isTextFieldEmpty(date)) return '';
      if (!_this.isValidDateString(date)) return 'Invalid Date or Date Format (' + _this.props.textFieldFormat.toLowerCase() + ')';
      if (_this.isBlocked((0, _moment2.default)(date))) return 'This Date is Unavailable';
      return '';
    };

    _this.hasOnlyDateCharacters = function (key) {
      // Allows accepted characters date characters
      var allowedFormat = /^[0-9. /-]*?$/;
      // Allows non navigational keys
      var isNavigational = key.length > 1;
      return isNavigational || allowedFormat.test(key);
    };

    _this.onTextFieldChange = function (event) {
      var dateString = event.target.value;
      if ((0, _arrayIncludes2.default)(_this.getModifiers(), 'blocked')) return;

      _this.setState({
        dateString: dateString,
        showDatePicker: false
      }, function () {
        // Unmounts and immediately Remounts DatePicker to align to textbox
        var dateString = _this.state.dateString;

        _this.props.onDateChange(_this.createReturnedEvent(dateString), _this.isTextFieldValueValid(dateString));
        var error = _this.getErrorMsg(dateString);

        _this.setState({
          error: error,
          showDatePicker: error.length <= 0,
          warning: ''
        });
      });
    };

    _this.onTextFieldKeyDown = function (event) {
      var tabbedBlur = event.key === "Tab";
      if (tabbedBlur) {
        _this.onClearFocus();
      } else if (event.ctrlKey || event.metaKey) {
        // Allows for ctrl, cmd and Windows key.
        return;
      } else if (!_this.hasOnlyDateCharacters(event.key)) {
        // Disallow any unaccepted characters to textfield
        event.preventDefault();
      }
    };

    _this.isValidDateString = function (textValue) {
      /** all common formats accepted using /, -, ., or space as delimiters also accepts leading and trailing spaces in case of copy/paste */
      var acceptedFormats = ['M/D/YY', 'M-D-YY', 'M.D.YY', 'M D YY', 'M/D/YYYY', 'M-D-YYYY', 'M.D.YYYY', 'M D YYYY'];
      return (typeof textValue === 'undefined' ? 'undefined' : _typeof(textValue)) !== 'object' && (0, _moment2.default)(textValue.trim(), acceptedFormats, true).isValid();
    };

    _this.isTextFieldEmpty = function (textValue) {
      return textValue === "";
    };

    _this.isTextFieldValueValid = function (dateString) {
      var isEmpty = _this.isTextFieldEmpty(dateString);
      var isValidDate = _this.isValidDateString(dateString);
      var isBlocked = _this.isBlocked(dateString);
      return isEmpty && !_this.props.required || isValidDate && !isBlocked;
    };

    _this.formatReturnedDate = function (date) {
      return _this.props.returnedDateFormat === 'dateObject' ? (0, _moment2.default)(date) : (0, _moment2.default)(date).format(_this.props.returnedDateFormat);
    };

    _this.createReturnedEvent = function (date) {
      return {
        target: {
          name: _this.props.name,
          value: date
        }
      };
    };

    _this.buildDatePicker = function () {
      var _this$props = _this.props,
          hideKeyboardShorcutsPanel = _this$props.hideKeyboardShorcutsPanel,
          isRTL = _this$props.isRTL,
          numberOfMonths = _this$props.numberOfMonths,
          monthFormat = _this$props.monthFormat,
          navNext = _this$props.navNext,
          navPrev = _this$props.navPrev,
          onNextMonthClick = _this$props.onNextMonthClick,
          onPrevMonthClick = _this$props.onPrevMonthClick,
          orientation = _this$props.orientation,
          renderMonth = _this$props.renderMonth,
          restrictOutsideDays = _this$props.restrictOutsideDays;
      var showDatePicker = _this.state.showDatePicker;

      return showDatePicker ? _react2.default.createElement(_SingleDatePicker2.default, Object.assign({
        dayPickerContainerClasses: _this.getDayPickerContainerClasses(),
        htmlId: 'datePicker',
        initialVisibleMonth: _this.getInitialVisibleMonth(),
        modifiers: _this.getModifiers(),
        onDayClick: _this.onDayClick,
        onDayMouseEnter: _this.onDayMouseEnter,
        onDayMouseLeave: _this.onDayMouseLeave
      }, {
        hideKeyboardShorcutsPanel: hideKeyboardShorcutsPanel, isRTL: isRTL, numberOfMonths: numberOfMonths, monthFormat: monthFormat, navNext: navNext, navPrev: navPrev, onNextMonthClick: onNextMonthClick, onPrevMonthClick: onPrevMonthClick, orientation: orientation, renderMonth: renderMonth, restrictOutsideDays: restrictOutsideDays
      })) : null;
    };

    _this.didInteractWithField = _this.didInteractWithField();
    var initialDateString = _this.getDateString(_this.props.selectedDate);
    _this.state = {
      dateString: initialDateString,
      error: _this.getErrorMsg(initialDateString, _this.props.selectedDate),
      hoverDate: null,
      showDatePicker: false,
      warning: _this.getWarningMsg(initialDateString)
    };
    return _this;
  }

  _createClass(SingleDatePickerFieldContainer, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      var dateUpdatedInternally = nextProps.selectedDate === this.props.selectedDate || nextProps.selectedDate === this.state.dateString;
      // If the field is not being interacted with, the date has changed externally
      if (!dateUpdatedInternally) {
        var newPassedDate = this.getDateString(nextProps.selectedDate);
        var warning = this.getWarningMsg(newPassedDate, true);
        var error = warning ? '' : this.getErrorMsg(newPassedDate, nextProps.selectedDate);

        this.setState({
          dateString: newPassedDate,
          error: error,
          warning: warning
        }, function () {
          _this2.props.onDateChange(_this2.createReturnedEvent(newPassedDate), !error);
        });
      }
    }

    // Modifiers of DatePicker classes

  }, {
    key: 'getDayPickerContainerClasses',
    value: function getDayPickerContainerClasses() {
      var _props = this.props,
          orientation = _props.orientation,
          anchorDirection = _props.anchorDirection;
      var _state = this.state,
          hoverDate = _state.hoverDate,
          showDatePicker = _state.showDatePicker;

      var dayPickerClassName = (0, _classnames2.default)('SingleDatePicker__picker', {
        'hidden': !showDatePicker,
        'SingleDatePicker__picker--direction-left': anchorDirection === _constants.ANCHOR_LEFT,
        'SingleDatePicker__picker--direction-right': anchorDirection === _constants.ANCHOR_RIGHT,
        'SingleDatePicker__picker--horizontal': orientation === _constants.HORIZONTAL_ORIENTATION,
        'SingleDatePicker__picker--vertical': orientation === _constants.VERTICAL_ORIENTATION,
        'SingleDatePicker__picker--valid-date-hovered': hoverDate && !this.isBlocked(hoverDate)
      });
      return dayPickerClassName;
    }

    // DatePicker Methods


    // Text Field methods


    // function needed to catch keystroke for tabbed blur and blocking unallowed characters.


    // this function mocks the returned event

  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          className = _props2.className,
          displayLabel = _props2.displayLabel,
          htmlId = _props2.htmlId,
          label = _props2.label,
          required = _props2.required,
          textFieldName = _props2.textFieldName,
          textFieldPlaceholder = _props2.textFieldPlaceholder;
      var _state2 = this.state,
          dateString = _state2.dateString,
          error = _state2.error,
          warning = _state2.warning;


      var datePicker = this.buildDatePicker();
      return _react2.default.createElement(_SingleDatePickerField2.default, Object.assign({ className: className, dateString: dateString, displayLabel: displayLabel, error: error, htmlId: htmlId, label: label, required: required, textFieldName: textFieldName, textFieldPlaceholder: textFieldPlaceholder, warning: warning }, {
        datePicker: datePicker,
        onOutsideClick: this.onOutsideClick,
        onTextFieldChange: this.onTextFieldChange,
        onTextFieldFocus: this.onFocus,
        onTextFieldKeyDown: this.onTextFieldKeyDown,
        onToggleInputButton: this.toggleInputButton
      }));
    }
  }]);

  return SingleDatePickerFieldContainer;
}(_react.Component);

exports.default = SingleDatePickerFieldContainer;


var propTypes = _SingleDatePickerShape2.default;
var newPropTypes = {
  /** css className given to SingleDatePickerField */
  className: _propTypes2.default.string,

  /** Boolean displays label if set to true. */
  displayLabel: _propTypes2.default.bool,

  /** String to display when error occurs. */
  error: _propTypes2.default.string,

  /** unique text id passed to SingleDatePickerField */
  htmlId: _propTypes2.default.string.isRequired,

  /** text applied to the ControlLabel of text input */
  label: _propTypes2.default.string.isRequired,

  /** restricts or allows outside dates */
  restrictOutsideDays: _propTypes2.default.bool,

  /** format of date expected from datepicker */
  returnedDateFormat: _propTypes2.default.string,

  /** initial date fed to date picker, accepts date object or string */
  selectedDate: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]).isRequired,

  /** name associated with text input */
  textFieldName: _propTypes2.default.string,

  /** placeholder for text input */
  textFieldPlaceholder: _propTypes2.default.string,

  /** format for date accepted in text input */
  textFieldFormat: _propTypes2.default.string
};

SingleDatePickerFieldContainer.propTypes = Object.assign(propTypes, newPropTypes);
SingleDatePickerFieldContainer.defaultProps = {
  anchorDirection: _constants.ANCHOR_RIGHT,
  disabled: false,
  displayLabel: true,
  hideKeyboardShortcutsPanel: true,
  horizontalMargin: 0,
  id: "singleDatePickerFieldContainer",
  initialVisibleMonth: function initialVisibleMonth() {
    return (0, _moment2.default)();
  },
  isDayBlocked: function isDayBlocked() {
    return false;
  }, // Example: isDayBlocked: day => (moment.weekdays(day.weekday()) === 'Friday')
  isDayHighlighted: function isDayHighlighted() {
    return false;
  },
  isOutsideRange: function isOutsideRange(day) {
    return !(0, _isInclusivelyAfterDay2.default)(day, (0, _moment2.default)());
  },
  isRTL: false,
  keepOpenOnDateSelect: false,
  navPrev: null,
  navNext: null,
  numberOfMonths: 1,
  onFocusChange: function onFocusChange() {},
  orientation: _constants.HORIZONTAL_ORIENTATION,
  monthFormat: 'MMMM YYYY', // Format of Month/Year label, not used functionally, only for display
  showClearDate: false,
  renderMonth: null,
  reopenPickerOnClearDate: false,
  required: false,
  restrictOutsideDays: true,
  returnedDateFormat: 'YYYY-MM-DDT00:00:00.000',
  textFieldPlaceholder: 'mm/dd/yy',
  textFieldFormat: "MM/DD/YY"
};