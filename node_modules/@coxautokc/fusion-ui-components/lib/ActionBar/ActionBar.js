'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _ButtonToolbar = require('react-bootstrap/lib/ButtonToolbar');

var _ButtonToolbar2 = _interopRequireDefault(_ButtonToolbar);

var _ActionItem = require('@coxautokc/fusion-ui-components/lib/ActionItem');

var _ActionItem2 = _interopRequireDefault(_ActionItem);

var _ActionBarTabs = require('./ActionBarTabs');

var _ActionBarTabs2 = _interopRequireDefault(_ActionBarTabs);

var _ActionDropdownMenu = require('./ActionDropdownMenu');

var _ActionDropdownMenu2 = _interopRequireDefault(_ActionDropdownMenu);

var _ActionDrawer = require('./ActionDrawer');

var _ActionDrawer2 = _interopRequireDefault(_ActionDrawer);

var _ActionDialog = require('./ActionDialog');

var _ActionDialog2 = _interopRequireDefault(_ActionDialog);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * <div>
 * Menu bar that will receive ActionItems and display them according to thier settings.
 * ActionItems can display as either tabs or dropdowns.
 * ActionItems supplied a 'fluid' actionPosition will render as a tab first but move to the dropdown menu if space on ActionBar is limited.
 * The placement of the ActionItems resets when resized.
 * All ActionItems can open to modals, open external/internal links, or fire a function outside of ActionBar.
 * Collapsible panels are only available for ActionItems that are set to 'staticTab'.
 */

// ActionBar uses React's PureComponent so it can do a shallow compare on props.children
// in willComponentReceiveProps.  This way it only rerenders if something on the top layer of ActionItem changes.
var ActionBar = function (_PureComponent) {
  _inherits(ActionBar, _PureComponent);

  function ActionBar(props) {
    _classCallCheck(this, ActionBar);

    var _this = _possibleConstructorReturn(this, (ActionBar.__proto__ || Object.getPrototypeOf(ActionBar)).call(this, props));

    _initialiseProps.call(_this);

    _this.breakpoints = [];
    _this.allowedActions = _this.getAllowedActions(_this.props.children);
    _this.state = {
      currentActionKey: null,
      currentActionComponent: null,
      showActionPanel: false,
      showActionDialog: false,
      showActionBar: false,
      actionTabsAtBreak: _this.buildActionsArray(_this.allowedActions, [_this.isInitialTab]),
      actionDropdownsAtBreak: _this.buildActionsArray(_this.allowedActions, [_this.isStaticDropdown])
    };
    return _this;
  }

  _createClass(ActionBar, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.children !== nextProps.children) {
        var panelOrModalIsVisible = this.state.showActionDialog || this.state.showActionPanel;
        var doForcedAction = !(nextProps.activeItem === this.props.activeItem && panelOrModalIsVisible);
        this.allowedActions = this.getAllowedActions(nextProps.children);
        this.resetActionsArrays(this.allowedActions, nextProps.activeItem, {}, doForcedAction);
      }
    }

    // Updates Actions Arrays on resize or componentWillRecieveProps


    // Build Tabs and Dropdown arrays initially and on resize


    // Conditions for actionItems placement


    // toggle related methods


    // General toggle sent down to dropdowns and tabs, calls the appropriate toggle (handleLink, handleExternalAction, toggleActionPanel, toggleActionDialog)

  }, {
    key: 'render',
    value: function render() {
      var htmlId = this.props.htmlId;
      var _state = this.state,
          actionTabsAtBreak = _state.actionTabsAtBreak,
          actionDropdownsAtBreak = _state.actionDropdownsAtBreak,
          currentActionKey = _state.currentActionKey,
          showActionBar = _state.showActionBar,
          showActionDialog = _state.showActionDialog,
          showActionPanel = _state.showActionPanel;

      return _react2.default.createElement(
        'div',
        { id: htmlId,
          className: 'action-bar'
        },
        showActionDialog && this.doActionDialog(),
        _react2.default.createElement(
          _ButtonToolbar2.default,
          { className: 'action-bar__btn-toolbar', ref: 'actionToolbar' },
          _react2.default.createElement(_ActionBarTabs2.default, {
            htmlId: 'actionBarTabs',
            activeKey: currentActionKey,
            actionTabs: actionTabsAtBreak,
            initialized: showActionBar,
            getTabWidths: this.calculateBreakpoints,
            toggleAction: this.toggleAction
          }),
          actionDropdownsAtBreak[0] && _react2.default.createElement(_ActionDropdownMenu2.default, {
            htmlId: 'actionDropdowns',
            actionDropdowns: actionDropdownsAtBreak,
            toggleAction: this.toggleAction
          })
        ),
        showActionPanel && this.doActionPanel()
      );
    }
  }]);

  return ActionBar;
}(_react.PureComponent);

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.componentDidMount = function () {
    _this2.resetActionsArrays(_this2.allowedActions, _this2.props.activeItem, { showActionBar: true }, true);
    window.addEventListener('resize', _this2.onResize);
  };

  this.componentWillUnmount = function () {
    window.removeEventListener('resize', _this2.onResize);
  };

  this.onResize = function () {
    return _this2.resetActionsArrays(_this2.allowedActions, _this2.props.activeItem, { currentActionKey: null,
      currentActionComponent: null,
      showActionPanel: false,
      showActionDialog: false
    });
  };

  this.getAllowedActions = function (children) {
    return _react2.default.Children.map(children, function (childComponent) {
      if (childComponent.type !== _ActionItem2.default) {
        throw new Error('ActionBar only accepts instances of <ActionBar.Item /> as children');
      } else if (childComponent.props.show) {
        return childComponent;
      }
    });
  };

  this.resetActionsArrays = function (allowedActions, activeItem, updatedStates) {
    var doForcedAction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var actionTabsAtBreak = _this2.buildActionsArray(allowedActions, [_this2.isTabContainedInBreakpoint]);
    var actionDropdownsAtBreak = _this2.buildActionsArray(allowedActions, [_this2.isContainedInDropdown]);

    var newUpdatedStates = updatedStates;
    if (doForcedAction) {
      var forcedAction = actionTabsAtBreak.concat(actionDropdownsAtBreak).find(function (item) {
        return item.name === activeItem;
      });
      var hasEnabledForcedAction = forcedAction && forcedAction.enable;

      if (!activeItem || !hasEnabledForcedAction) {
        newUpdatedStates = Object.assign({
          currentActionKey: null,
          currentActionComponent: null,
          showActionPanel: false,
          showActionDialog: false
        }, updatedStates);
      } else {
        _this2.setForcedAction(activeItem, forcedAction);
      }
    }

    _this2.setState({
      actionTabsAtBreak: actionTabsAtBreak,
      actionDropdownsAtBreak: actionDropdownsAtBreak
    }, function () {
      _this2.setState(Object.assign({}, newUpdatedStates));
    });
  };

  this.setForcedAction = function (activeItem, forcedAction) {
    var actionItem = forcedAction.actionItem,
        actionKey = forcedAction.actionKey,
        toggleMethod = forcedAction.toggleMethod;

    toggleMethod(actionKey, actionItem.props.openToComponent);
  };

  this.buildActionsArray = function (allowedActions, filterConditions) {
    return _react2.default.Children.map(allowedActions, function (childComponent, actionKey) {
      var props = childComponent.props;
      var name = props.name,
          enable = props.enable;


      var allConditionsPass = Object.keys(filterConditions).every(function (filter) {
        return filterConditions[filter](childComponent, actionKey) === true;
      });

      if (allConditionsPass) {
        var toggleMethod = _this2.getToggleMethod(props.actionDisplay);
        return { actionItem: childComponent, actionKey: actionKey, toggleMethod: toggleMethod, name: name, enable: enable };
      }
    });
  };

  this.calculateBreakpoints = function (actionKey, width) {
    if (width === 0) return;
    var breakpoints = _this2.breakpoints;

    var lastBreakpoint = Number(breakpoints.slice(-1));
    var nextBreakpoint = lastBreakpoint + width;
    breakpoints.push(nextBreakpoint);
  };

  this.getResponsiveTabCount = function () {
    var toolbarWidth = _reactDom2.default.findDOMNode(_this2.refs['actionToolbar']).clientWidth;
    var dropdownButtonWidth = 50; // Width of Dropdown Button
    var containerWidth = toolbarWidth - dropdownButtonWidth;

    var currentTabCount = _this2.breakpoints.filter(function (breakpoint) {
      return containerWidth > breakpoint;
    }).length;

    return currentTabCount;
  };

  this.isInitialTab = function (actionItem) {
    return _this2.isStaticTab(actionItem) || _this2.isFluid(actionItem);
  };

  this.isTabContainedInBreakpoint = function (actionItem, actionKey) {
    if (_this2.isStaticTab(actionItem)) {
      return true;
    } else if (_this2.isStaticDropdown(actionItem)) {
      return false;
    } else if (_this2.isFluid(actionItem)) {
      return _this2.getResponsiveTabCount() > actionKey;
    }
  };

  this.isContainedInDropdown = function (actionItem, actionKey) {
    return !_this2.isTabContainedInBreakpoint(actionItem, actionKey);
  };

  this.isStaticDropdown = function (actionItem) {
    return actionItem.props.actionPosition === 'staticDropdown';
  };

  this.isFluid = function (actionItem) {
    return actionItem.props.actionPosition === 'fluid';
  };

  this.isStaticTab = function (actionItem) {
    return actionItem.props.actionPosition === 'staticTab';
  };

  this.getToggleMethod = function (action) {
    switch (action) {
      case "collapsiblePanel":
        return _this2.toggleActionPanel;
      case "modal":
        return _this2.toggleActionDialog;
      case "link":
        return _this2.handleLink;
      default:
        return;
    }
  };

  this.toggleAction = function (eventKey) {
    var actionKey = eventKey.actionKey,
        actionLink = eventKey.actionLink,
        name = eventKey.name,
        openToComponent = eventKey.openToComponent,
        onClick = eventKey.onClick,
        toggleMethod = eventKey.toggleMethod;

    if (actionLink) {
      toggleMethod(actionLink, name);
      return;
    }

    if (onClick) {
      _this2.handleExternalAction(actionKey, onClick, name);
      if (toggleMethod) setTimeout(function () {
        toggleMethod(actionKey, openToComponent, name);
      });
    } else {
      toggleMethod(actionKey, openToComponent, name);
    };
  };

  this.onEvent = function (actionName, actionType, actionFired, actionState) {
    if (_this2.props.onEvent && actionName) {
      var event = { actionName: actionName, actionType: actionType, actionFired: actionFired, actionState: actionState };
      _this2.props.onEvent(event);
    }
  };

  this.handleLink = function (link, actionName) {
    var url = link.url,
        target = link.target,
        specs = link.specs,
        replace = link.replace;

    window.open(url, target, specs, replace);
    _this2.onEvent(actionName, 'link', link, 'Link Fired');
  };

  this.handleExternalAction = function (key, externalAction, actionName) {
    externalAction();
    _this2.onEvent(actionName, 'externalAction', externalAction, 'External Function Fired');
  };

  this.toggleActionPanel = function (key, component, actionName) {
    var isSameKey = _this2.state.currentActionKey === key ? !_this2.state.showActionPanel : true;
    _this2.setState({
      currentActionKey: isSameKey ? key : null,
      currentActionComponent: component,
      showActionPanel: isSameKey,
      showActionDialog: false
    }, function () {
      _this2.onEvent(actionName, 'collapsiblePanel', component, _this2.state.showActionPanel ? 'Opened' : 'Closed');
    });
  };

  this.toggleActionDialog = function (key, component, actionName) {
    _this2.setState(function (prevState) {
      return {
        currentActionKey: key,
        currentActionComponent: component,
        showActionDialog: !prevState.showActionDialog,
        showActionPanel: false
      };
    }, function () {
      _this2.onEvent(actionName, 'modal', component, _this2.state.showActionDialog ? 'Opened' : 'Closed');
    });
  };

  this.doActionDialog = function () {
    var _state2 = _this2.state,
        currentActionKey = _state2.currentActionKey,
        currentActionComponent = _state2.currentActionComponent,
        showActionDialog = _state2.showActionDialog;

    var closeDialog = function closeDialog() {
      _this2.toggleActionDialog(currentActionKey);
    };
    return _react2.default.createElement(_ActionDialog2.default, {
      htmlId: 'actionDialog',
      actionComponent: currentActionComponent,
      closeDialog: closeDialog,
      showActionDialog: showActionDialog
    });
  };

  this.doActionPanel = function () {
    var _state3 = _this2.state,
        currentActionKey = _state3.currentActionKey,
        currentActionComponent = _state3.currentActionComponent,
        showActionPanel = _state3.showActionPanel;

    var closePanel = function closePanel() {
      _this2.toggleActionPanel(currentActionKey);
    };
    return _react2.default.createElement(_ActionDrawer2.default, {
      htmlId: 'actionPanel',
      actionComponent: currentActionComponent,
      closePanel: closePanel,
      showActionPanel: showActionPanel
    });
  };
};

ActionBar.propTypes = {
  /** This ActionItem is opened when ActionBar is initialized or prop is updated.
   * This value should correspond to the relevant ActionBar.Item's 'name' prop. */
  activeItem: _propTypes2.default.string,

  /** Children to be passed through. Only accepts instances of ActionBar.Item or ActionItem.
   * See <a href="/#ActionItem">ActionItem</a> for list of props.</a> */
  children: _propTypes2.default.oneOfType([_propTypes2.default.arrayOf(_propTypes2.default.node), _propTypes2.default.node]),

  /** Globally unique and descriptive HTML ID. Used by QA for automated testing. */
  htmlId: _propTypes2.default.string.isRequired,

  /** Callback function that returns on ActionBar selections.
   * <br/>
   * Event returned is shaped as such:
   * <ul>
    * <li>actionName: name prop of actionItem clicked</li>
    * <li>actionType: type of action made, based off of ActionItem's actionDisplay prop</li>
    * <li>actionFired: action made onClick, component or link opened to, or external function fired</li>
    * <li>actionState: opened, closed, fired, etc.. state of ActionItem</li>
   * </ul>
  */
  onEvent: _propTypes2.default.func
};

ActionBar.Item = _ActionItem2.default;

exports.default = ActionBar;