'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _d = require('d3');

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TrendLine = function (_React$Component) {
  _inherits(TrendLine, _React$Component);

  function TrendLine(props) {
    _classCallCheck(this, TrendLine);

    var _this = _possibleConstructorReturn(this, (TrendLine.__proto__ || Object.getPrototypeOf(TrendLine)).call(this, props));

    _this.updateSize = function () {
      var node = _reactDom2.default.findDOMNode(_this);
      var parentWidth = node.offsetWidth;
      parentWidth < _this.props.width ? _this.setState({ width: parentWidth }) : _this.setState({ width: _this.props.width });
    };

    _this.minMaxing = function () {
      var _self = _this;

      var minMax = {};
      var lineData = _this.props.lineExtend;
      minMax['xMin'] = _d2.default.min(lineData.map(function (d) {
        return d[_self.props.xDataKey];
      }));
      minMax['xMax'] = _d2.default.max(lineData.map(function (d) {
        return d[_self.props.xDataKey];
      }));

      return minMax;
    };

    _this.getEndPoints = function () {
      var _self = _this;
      var data = void 0;

      if (_this.props.lineNumbers === 'single') {
        data = _this.props.lineExtend;
      } else {
        data = _this.props.data;
      }

      var xSeries = data.map(function (d) {
        return d[_self.props.xDataKey];
      });
      var ySeries = data.map(function (d) {
        return d[_self.props.yDataKey];
      });

      var leastSquaresCoeff = _this.leastSquares(xSeries, ySeries);
      var trendExtend = _this.minMaxing();

      var x1 = trendExtend.xMin;
      var y1 = leastSquaresCoeff.slope * x1 + leastSquaresCoeff.yIntercept;
      var x2 = trendExtend.xMax;
      var y2 = leastSquaresCoeff.slope * x2 + leastSquaresCoeff.yIntercept;

      var trendData = [{
        "label": "Trend Line",
        'x': x1,
        'y': y1
      }, {
        "label": "Trend Line",
        'x': x2,
        'y': y2
      }];

      _this.setState({ data: trendData });
    };

    _this.state = {
      width: _this.props.width,
      data: []
    };
    return _this;
  }

  _createClass(TrendLine, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      var _self = this;
      window.addEventListener('resize', function () {
        _self.minMaxing.bind(_self);
        _self.updateSize.bind(_self);
        _self.getEndPoints.bind(_self);
      }, false);
      this.setState({ width: this.props.width });
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.repaintComponent();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      var _self = this;
      window.removeEventListener('resize', function () {
        _self.minMaxing.bind(_self);
        _self.updateSize.bind(_self);
        _self.getEndPoints.bind(_self);
      }, false);
    }
  }, {
    key: 'repaintComponent',
    value: function repaintComponent() {
      var _self = this;
      var forceResize = function forceResize() {
        _self.minMaxing();
        _self.updateSize();
        _self.getEndPoints();
      };
      function onRepaint(callback) {
        setTimeout(function () {
          window.requestAnimationFrame(callback);
        }, 0);
      }
      onRepaint(forceResize);
    }
  }, {
    key: 'createChart',
    value: function createChart(_self) {
      // Create line
      this.line = _d2.default.svg.line().x(function (d) {
        return this.props.x(d[_self.props.xDataKey]);
      }).y(function (d) {
        return this.props.y(d[_self.props.yDataKey]);
      });

      this.dataNest = _d2.default.nest().key(function (d) {
        return d.label;
      }).entries(this.state.data);
    }

    // returns slope, yIntercept and r-square of the line

  }, {
    key: 'leastSquares',
    value: function leastSquares(xSeries, ySeries) {
      var ls = {};

      var reduceSumFunc = function reduceSumFunc(prev, cur) {
        return prev + cur;
      };

      var xBar = xSeries.reduce(reduceSumFunc) * 1.0 / xSeries.length;
      var yBar = ySeries.reduce(reduceSumFunc) * 1.0 / ySeries.length;

      var ssXX = xSeries.map(function (d) {
        return Math.pow(d - xBar, 2);
      }).reduce(reduceSumFunc);

      var ssYY = ySeries.map(function (d) {
        return Math.pow(d - yBar, 2);
      }).reduce(reduceSumFunc);

      var ssXY = xSeries.map(function (d, i) {
        return (d - xBar) * (ySeries[i] - yBar);
      }).reduce(reduceSumFunc);

      ls['slope'] = ssXY / ssXX;
      ls['yIntercept'] = yBar - xBar * ls.slope;
      ls['rSquare'] = Math.pow(ssXY, 2) / (ssXX * ssYY);

      return ls;
    }

    // extends trend line the full width of the graph


    // Makes the two points needed for the trend line to graph

  }, {
    key: 'render',
    value: function render() {
      this.createChart(this);

      var _self = this;

      var line = this.dataNest.map(function (d, i) {
        return _react2.default.createElement('path', {
          key: i,
          className: 'trend-line',
          d: _self.line(d.values),
          stroke: _self.props.lineStroke,
          opacity: '.4',
          strokeWidth: 3,
          strokeLinecap: 'round' });
      });

      return _react2.default.createElement(
        'g',
        null,
        line
      );
    }
  }]);

  return TrendLine;
}(_react2.default.Component);

TrendLine.propTypes = {
  data: _propTypes2.default.array,
  height: _propTypes2.default.number,
  lineExtend: _propTypes2.default.array,
  lineNumbers: _propTypes2.default.oneOf(['single', 'multi']),
  lineStroke: _propTypes2.default.string,
  margin: _propTypes2.default.object,
  width: _propTypes2.default.number,
  x: _propTypes2.default.func,
  xDataKey: _propTypes2.default.string.isRequired,
  y: _propTypes2.default.func,
  yDataKey: _propTypes2.default.string.isRequired,
  yMaxBuffer: _propTypes2.default.number
};

TrendLine.defaultProps = {
  width: 1920,
  height: 400,
  lineNumbers: 'multi',
  margin: {
    top: 10,
    right: 40,
    bottom: 20,
    left: 40
  },
  yMaxBuffer: 100
};

exports.default = TrendLine;