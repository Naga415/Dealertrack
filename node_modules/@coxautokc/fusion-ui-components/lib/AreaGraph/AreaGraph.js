'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _d = require('d3');

var _d2 = _interopRequireDefault(_d);

var _Axis = require('../internal/Axis');

var _Axis2 = _interopRequireDefault(_Axis);

var _AxisLabel = require('../internal/AxisLabel');

var _AxisLabel2 = _interopRequireDefault(_AxisLabel);

var _Grid = require('../internal/Grid');

var _Grid2 = _interopRequireDefault(_Grid);

var _DataPoints = require('../internal/DataPoints');

var _DataPoints2 = _interopRequireDefault(_DataPoints);

var _Tooltip = require('../internal/Tooltip');

var _Tooltip2 = _interopRequireDefault(_Tooltip);

var _Legend = require('../internal/Legend');

var _Legend2 = _interopRequireDefault(_Legend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** Areagraph Chart */
var AreaGraph = function (_React$Component) {
  _inherits(AreaGraph, _React$Component);

  function AreaGraph(props) {
    _classCallCheck(this, AreaGraph);

    var _this = _possibleConstructorReturn(this, (AreaGraph.__proto__ || Object.getPrototypeOf(AreaGraph)).call(this, props));

    _this.updateSize = function () {
      var node = _reactDom2.default.findDOMNode(_this);
      var parentWidth = node.offsetWidth;
      parentWidth < _this.props.width ? _this.setState({ width: parentWidth }) : _this.setState({ width: _this.props.width });
    };

    _this.showToolTip = function (e) {
      var pointColor = e.target.getAttribute('fill');
      e.target.setAttribute('fill', '#6f8679');
      _this.setState({
        tooltip: {
          display: true,
          data: {
            key: e.target.getAttribute('data-key'),
            value: e.target.getAttribute('data-value')
          },
          pos: {
            x: e.target.getAttribute('cx'),
            y: e.target.getAttribute('cy')
          }
        },
        dataPointColor: pointColor
      });
    };

    _this.hideToolTip = function (e) {
      e.target.setAttribute('fill', _this.state.dataPointColor);
      _this.setState({
        tooltip: {
          display: false,
          data: {
            key: '',
            value: ''
          },
          pos: {
            x: 0,
            y: 0
          }
        },
        dataPointColor: ''
      });
    };

    _this.state = {
      tooltip: {
        display: false,
        data: {
          key: '',
          value: ''
        },
        pos: {
          x: 0,
          y: 0
        }
      },
      dataPointColor: '',
      width: _this.props.width,
      data: []
    };
    return _this;
  }

  _createClass(AreaGraph, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      window.addEventListener('resize', this.updateSize, false);
      this.setState({ width: this.props.width });
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.reloadBarData();
      this.repaintComponent();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.removeEventListener('resize', this.updateSize, false);
    }
  }, {
    key: 'repaintComponent',
    value: function repaintComponent() {
      var forceResize = this.updateSize;
      function onRepaint(callback) {
        setTimeout(function () {
          window.requestAnimationFrame(callback);
        }, 0);
      }
      onRepaint(forceResize);
    }
  }, {
    key: 'createChart',
    value: function createChart(_self) {
      if (this.props.colors) {
        this.color = _d2.default.scale.ordinal().range(this.props.colors);
      } else {
        this.color = _d2.default.scale.category10();
      }

      var xLabelHeightOffset = this.props.xAxisLabel ? 30 : 0;
      var yLabelWidthOffset = this.props.yAxisLabel ? 20 : 0;

      // Width of graph
      this.w = this.state.width - (this.props.margin.left + this.props.margin.right + yLabelWidthOffset);

      // Height of graph
      this.h = this.props.height - (this.props.margin.top + this.props.margin.bottom + xLabelHeightOffset);

      // X axis scale
      if (this.props.dataType !== 'date') {
        this.xScale = _d2.default.scale.linear().domain([_d2.default.min(this.state.data, function (d) {
          return d[_self.props.xDataKey];
        }), _d2.default.max(this.state.data, function (d) {
          return d[_self.props.xDataKey];
        })]).range([0, this.w]);

        if (this.props.dataPercent === 'x') {
          this.xAxis = _d2.default.svg.axis().scale(this.xScale).orient('bottom').tickFormat(function (x) {
            return x + '%';
          });
        } else {
          this.xAxis = _d2.default.svg.axis().scale(this.xScale).orient('bottom').ticks(Math.floor(this.w / 100));
        }
      } else {
        this.xScale = _d2.default.time.scale().domain(
        // Find min and max axis value
        _d2.default.extent(this.state.data, function (d) {
          return d[_self.props.xDataKey];
        }))
        // Set range from 0 to width of container
        .rangeRound([0, this.w]);

        this.xAxis = _d2.default.svg.axis().scale(this.xScale).orient('bottom').ticks(Math.floor(this.w / 100)).tickFormat(_d2.default.time.format(this.props.xFormat));
      }

      // Y axis scale
      this.yScale = _d2.default.scale.linear().domain([
      // Find min axis value and subtract buffer
      _d2.default.min(this.state.data, function (d) {
        if (typeof _self.props.yMin === "number") {
          return _self.props.yMin;
        } else {
          return d[_self.props.yDataKey] - _self.props.yMaxBuffer;
        }
      }),
      // Find max axis value and add buffer
      _d2.default.max(this.state.data, function (d) {
        if (typeof _self.props.yMax === "number") {
          return _self.props.yMax;
        } else {
          return d[_self.props.yDataKey] + _self.props.yMaxBuffer;
        }
      })])
      // Set range from height of container to 0
      .range([this.h, 0]);

      // Create area
      this.area = _d2.default.svg.area().x(function (d) {
        return this.xScale(d[_self.props.xDataKey]);
      }).y0(this.h).y1(function (d) {
        return this.yScale(d[_self.props.yDataKey]);
      }).interpolate(this.props.lineType);

      this.dataNest = _d2.default.nest().key(function (d) {
        return d[_self.props.labelKey];
      }).entries(this.state.data);

      if (this.props.dataPercent === 'y') {
        this.yAxis = _d2.default.svg.axis().scale(this.yScale).orient('left').ticks(5).tickFormat(function (x) {
          return x + '%';
        });
      } else {
        this.yAxis = _d2.default.svg.axis().scale(this.yScale).orient('left').ticks(5);
      }

      this.yGrid = _d2.default.svg.axis().scale(this.yScale).orient('left').ticks(5).tickSize(-this.w, 0, 0).tickFormat("");

      this.transform = 'translate(' + (this.props.margin.left + yLabelWidthOffset) + ',' + this.props.margin.top + ')';
    }
  }, {
    key: 'reloadBarData',
    value: function reloadBarData() {
      var _this2 = this;

      var data = this.props.data;

      // Format date for d3 to use
      var parseDate = _d2.default.time.format(this.props.dateFormat).parse;

      data.forEach(function (value, i) {
        var d = data[i];
        if (_this2.props.dataType === 'date') {
          if (typeof d[_this2.props.xDataKey] === "string") {
            d[_this2.props.xDataKey] = parseDate(d[_this2.props.xDataKey]);
          }
          data[i] = d;
        }
      });

      this.setState({ data: data });
    }
  }, {
    key: 'render',
    value: function render() {
      this.createChart(this);

      var _self = this;

      var lines = this.dataNest.map(function (d, i) {
        return _react2.default.createElement(
          'g',
          { key: i },
          _react2.default.createElement('path', {
            d: _self.area(d.values),
            fill: _self.color(i),
            stroke: _self.props.strokeColor,
            opacity: '.9',
            strokeWidth: 3 }),
          _react2.default.createElement(_DataPoints2.default, {
            data: d.values,
            x: _self.xScale,
            y: _self.yScale,
            stroke: '#ffffff',
            fill: _self.color(i),
            showToolTip: _self.showToolTip,
            hideToolTip: _self.hideToolTip,
            removeFirstAndLast: _self.props.removeFirstAndLast,
            dateFormat: _self.props.dataPointDateFormat,
            xDataKey: _self.props.xDataKey,
            yDataKey: _self.props.yDataKey }),
          _react2.default.createElement(_Tooltip2.default, {
            tooltip: _self.state.tooltip,
            bgColor: _self.props.tooltipBgColor,
            xValue: _self.props.xToolTipLabel,
            yValue: _self.props.yToolTipLabel })
        );
      });

      var customClassName = "";

      if (this.props.className) {
        customClassName = " " + this.props.className;
      }

      return _react2.default.createElement(
        'div',
        null,
        this.props.title && _react2.default.createElement(
          'h3',
          null,
          this.props.title
        ),
        _react2.default.createElement(
          'svg',
          { className: "rd3r-chart rd3r-area-graph" + customClassName, id: this.props.htmlId, width: this.state.width, height: this.props.height },
          _react2.default.createElement(
            'g',
            { transform: this.transform },
            _react2.default.createElement(_Grid2.default, { h: this.h, grid: this.yGrid, gridType: 'y' }),
            _react2.default.createElement(_Axis2.default, { h: this.h, axis: this.yAxis, axisType: 'y' }),
            _react2.default.createElement(_Axis2.default, { h: this.h, axis: this.xAxis, axisType: 'x' }),
            this.props.xAxisLabel && _react2.default.createElement(_AxisLabel2.default, { key: 0, h: this.h, w: this.w, axisLabel: this.props.xAxisLabel, axisType: 'x' }),
            this.props.yAxisLabel && _react2.default.createElement(_AxisLabel2.default, { key: 1, h: this.h, w: this.w, axisLabel: this.props.yAxisLabel, axisType: 'y' }),
            lines
          )
        ),
        this.props.displayLegend && _react2.default.createElement(_Legend2.default, { data: this.state.data, labelKey: this.props.labelKey, colors: this.color })
      );
    }
  }]);

  return AreaGraph;
}(_react2.default.Component);

AreaGraph.propTypes = {

  /** Adds additional class name(s). */
  className: _propTypes2.default.string,

  /** Override colors for area fill e.g. <code>["#084b62", "yellow", "#ab264b"]</code>. The number of colors should match the number of data series. */
  colors: _propTypes2.default.array,

  /** Data to be graphed. */
  data: _propTypes2.default.array.isRequired,

  /** If set to either x or y, that axis will be displayed with a % at the end of the axis numbers. */
  dataPercent: _propTypes2.default.string,

  /** Tooltip date format display <a href="https://github.com/d3/d3-3.x-api-reference/blob/master/Time-Formatting.md#format" target="_blank">d3.js v3 time api</a>. */
  dataPointDateFormat: _propTypes2.default.string,

  /** Data type date, percent, or number. This will format the number the right way for d3. */
  dataType: _propTypes2.default.string,

  /** Date format being passed via data <a href="https://github.com/d3/d3-3.x-api-reference/blob/master/Time-Formatting.md#format" target="_blank">d3.js v3 time api</a>. */
  dateFormat: _propTypes2.default.string,

  /** Display legend. */
  displayLegend: _propTypes2.default.bool,

  /** Graph height. */
  height: _propTypes2.default.number,

  /** Globally unique and descriptive HTML ID. Used by QA for automated testing. */
  htmlId: _propTypes2.default.string.isRequired,

  /** Label key-value pair key value in data. */
  labelKey: _propTypes2.default.string,

  /** Line display type <a href="https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_interpolate" target="_blank">d3.js v3 line api</a>. */
  lineType: _propTypes2.default.string,

  /** Margin for graph area. */
  margin: _propTypes2.default.object,

  /** Remove first and last data point. */
  removeFirstAndLast: _propTypes2.default.bool,

  /** Stroke color. */
  strokeColor: _propTypes2.default.string,

  /** Graph title. */
  title: _propTypes2.default.string,

  /** Tooltip background color. */
  tooltipBgColor: _propTypes2.default.string,

  /** Graph max-width. */
  width: _propTypes2.default.number,

  /** X Axis label. */
  xAxisLabel: _propTypes2.default.string,

  /** X axis key-value pair key value. */
  xDataKey: _propTypes2.default.string.isRequired,

  /** X Axis date label format if dataType is a date. <a href="https://github.com/d3/d3-3.x-api-reference/blob/master/Time-Formatting.md#format" target="_blank">d3.js v3 time api</a>. */
  xFormat: _propTypes2.default.string,

  /** X Axis tooltip label. */
  xToolTipLabel: _propTypes2.default.string,

  /** Y Axis label. */
  yAxisLabel: _propTypes2.default.string,

  /** Y axis key-value pair key value. */
  yDataKey: _propTypes2.default.string.isRequired,

  /** Set Y maximum value to be displayed. */
  yMax: _propTypes2.default.number,

  /** Set Y padding for min and max value. */
  yMaxBuffer: _propTypes2.default.number,

  /** Set Y minimum value to be displayed. */
  yMin: _propTypes2.default.number,

  /** Y Axis tooltip label. */
  yToolTipLabel: _propTypes2.default.string
};

AreaGraph.defaultProps = {
  width: 1920,
  height: 400,
  labelKey: "label",
  dateFormat: '%m-%d-%Y',
  dataType: 'date',
  xFormat: '%a %e',
  xToolTipLabel: 'x',
  yToolTipLabel: 'y',
  displayLegend: true,
  lineType: 'linear',
  removeFirstAndLast: false,
  strokeColor: '#ffffff',
  margin: {
    top: 10,
    right: 40,
    bottom: 30,
    left: 40
  },
  yMaxBuffer: 100
};

exports.default = AreaGraph;