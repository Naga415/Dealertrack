'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _FormControl = require('react-bootstrap/lib/FormControl');

var _FormControl2 = _interopRequireDefault(_FormControl);

var _FormGroup = require('react-bootstrap/lib/FormGroup');

var _FormGroup2 = _interopRequireDefault(_FormGroup);

var _InputGroup = require('react-bootstrap/lib/InputGroup');

var _InputGroup2 = _interopRequireDefault(_InputGroup);

var _HelpBlock = require('react-bootstrap/lib/HelpBlock');

var _HelpBlock2 = _interopRequireDefault(_HelpBlock);

var _Button = require('@coxautokc/fusion-ui-components/lib/Button');

var _Button2 = _interopRequireDefault(_Button);

var _Label = require('@coxautokc/fusion-ui-components/lib/internal/Label');

var _Label2 = _interopRequireDefault(_Label);

var _IconAccessTime = require('../Icons/IconAccessTime');

var _IconAccessTime2 = _interopRequireDefault(_IconAccessTime);

var _OutsideClickHandler = require('react-dates/lib/components/OutsideClickHandler');

var _OutsideClickHandler2 = _interopRequireDefault(_OutsideClickHandler);

require('./_timePicker.scss');

var _TimeSlot = require('../internal/TimeSlot');

var _TimeSlot2 = _interopRequireDefault(_TimeSlot);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// TODO it would be nice if we could break the text field out into it's own dumb component
// import TimePickerField from './TimePickerField';

// Components from 'react-dates'


/** Custom time picker component.<br/>
  Interval (minutes) passed within timeSlots prop is used to calculate time slots for 24 hrs.<br/>
  Initially, when the dropdown opens, focus is put on 9:MM AM.<br/>
  The date passed should be a UTC date string with timezone offset.<br/>
  Ex: 2017-04-20 13:42:25-0500<br/>
  Input accepts the following formats and converts to HH:MM AM/PM):<br/>
  <ul>
  <li>HH AM/PM</li>
  <li>HH:MM am/pm</li>
  <li>HH:MM a/p</li>
  <li>HH a/p</li>
  <li>HHMM a/p</li>
  <li>HHMMa/p</li>
  <li>HHMM am/pm</li>
  <li>HHMMam/pm</li>
  <li>HH</li>
  <li>HH:MM</li>
  <li>HHMM</li>
  </ul>
  For inputs without AM/PM, 9:00-11:59 is converted to be AM, 1:00-8:00 is converted to PM.
*/
var TimePicker = function (_Component) {
  _inherits(TimePicker, _Component);

  function TimePicker(props) {
    _classCallCheck(this, TimePicker);

    var _this = _possibleConstructorReturn(this, (TimePicker.__proto__ || Object.getPrototypeOf(TimePicker)).call(this, props));

    _this.componentDidMount = function () {
      _this.props.onChange(_this.createReturnedEvent(_this.state.timeString), _this.state.error.length === 0);
    };

    _this.didInteractWithField = function () {
      return !!_this.props.error;
    };

    _this.getTimeString = function (time) {
      if (_this.isValidTimeString(time)) return _this.formatTimeInput(time);
      if (_this.getTimeFromUTC(time)) return _this.getTimeFromUTC(time);
      return time;
    };

    _this.getTimeFromUTC = function (time) {
      // Checks if time is in valid ISO 8601 format (UTC & offset)
      var isValidUTC = (0, _moment2.default)(time, _moment2.default.ISO_8601).isValid();
      var selectedTime = isValidUTC ? (0, _moment2.default)(time).format('h:mm A') : "";
      return selectedTime;
    };

    _this.getTimeSlotsArray = function (timeSlots) {
      if (Array.isArray(timeSlots)) {
        return _this.validateArrayData(timeSlots);
      }
      var startTime = 0;
      var endTime = 24 * 60;
      var generatedTimeSlots = [];
      var interval = timeSlots;
      for (var index = 0; startTime < endTime; index++) {
        var hours = Math.floor(startTime / 60);
        var minutes = startTime % 60;
        generatedTimeSlots[index] = _this.getTimeSlot(hours, minutes);
        startTime += interval;
      }
      return generatedTimeSlots;
    };

    _this.validateArrayData = function (timeSlots) {
      if (!timeSlots) {
        return [];
      } else {
        for (var i in timeSlots) {
          var formattedTimeSlot = _this.formatTimeInput('', timeSlots[i]);
          if (formattedTimeSlot) {
            timeSlots[timeSlots.indexOf(timeSlots[i])] = formattedTimeSlot;
          } else {
            throw new Error('Invalid time slot format in props');
          }
        }
        return timeSlots;
      }
    };

    _this.getTimeSlot = function (hours, minutes) {
      var amPm = hours >= 12 ? ' PM' : ' AM';
      var timeSlotMinutes = minutes;
      var timeSlotHours = void 0;
      if (hours % 12 === 0) {
        timeSlotHours = 12;
      } else {
        timeSlotHours = (hours % 12).toString().slice(-2);
      }
      return timeSlotHours + ':' + ('0' + timeSlotMinutes).slice(-2) + amPm;
    };

    _this.getScrollToTimeSlot = function () {
      var timeSlotsArray = _this.timeSlotsArray;
      var timeString = _this.state.timeString;


      var isValidTime = _this.isValidTimeString(timeString);

      if (!isValidTime) {
        // When component renders and no time is selected or invalid format is entered, we automatically scroll to 9:00am.
        for (var i in timeSlotsArray) {
          if (timeSlotsArray[i].substring(0, 1) === '9') {
            return timeSlotsArray[i];
          }
        }
      } else if (timeSlotsArray.indexOf(timeString) > -1) {
        // If a valid time is selected and it is one of the timeSlots, scroll to selectedTime
        return timeString;
      } else {
        // When the time entered is not one of timeSlots, we find the next timeSlot using moment
        return _this.getTimeSlotClosestToEnteredTime();
      }
    };

    _this.scrollToTimeSlot = function () {
      var element = _reactDom2.default.findDOMNode(_this.element);
      if (element) {
        element.parentNode.scrollTop = element.offsetTop - 10;
      }
    };

    _this.getTimeSlotClosestToEnteredTime = function () {
      var inputTime = (0, _moment2.default)(_this.state.timeString, 'h:mm A');
      return _this.timeSlotsArray.find(function (timeSlot) {
        var closestTimeSlot = (0, _moment2.default)(timeSlot, 'h:mm A');
        return inputTime < closestTimeSlot;
      });
    };

    _this.getTimeSlotClassName = function (timeSlot) {
      var timeSlotClassName = 'time-slot__item ';
      var blockedTimeSlots = _this.blockedTimeSlots;
      var _this$state = _this.state,
          timeString = _this$state.timeString,
          error = _this$state.error;

      if (blockedTimeSlots && blockedTimeSlots.indexOf(timeSlot) !== -1) {
        timeSlotClassName += ' time-slot--blocked ';
        return timeSlotClassName;
      } else {
        timeSlotClassName += ' time-slot--available ';
        if (timeString === timeSlot && !error) {
          timeSlotClassName += ' time-slot--selected ';
        }
        return timeSlotClassName;
      }
    };

    _this.formatTimeInput = function (value, timeSlot) {
      var inputText = timeSlot && typeof timeSlot === 'string' ? timeSlot : value;

      var hourWithAmPm = /^(0?[1-9]|1[012])[APap][mM]$/; // Check for input HH AM/PM
      var hourWithoutAmPm = /^(0?[1-9]|1[012])$/; // Check for input HH
      var hoursWithAP = /^(0?[1-9]|1[012])[APap]$/; // Check for input HH:MM Aa/pP
      var hourAndMinutesWithAmPm = /^(0?[1-9]|1[012])(:[0-5]\d)[APap][mM]$/; // Check for input HH:MM AM/PM
      var hoursAndMinutesWithoutAmPm = /^(0?[1-9]|1[012])(:[0-5]\d)$/; // Check for input HH:MM
      var hoursAndMinutesWithAP = /^(0?[1-9]|1[012])(:[0-5]\d)[APap]$/; // Check for input HH:MM Aa/pP
      var hoursAndMinutes = /^(0?[1-9]|1[012])([0-5]\d)$/; // Check for hhmm or hmm
      var hoursAndMiutesWithoutColonWithAP = /^(0?[1-9]|1[012])([0-5]\d)[APap]$/; // Check for hhmmAaPp
      var hoursAndMiutesWithoutColonWithAmPm = /^(0?[1-9]|1[012])([0-5]\d)[APap][mM]$/; // Check for hhmmAM/PM

      inputText = inputText.replace(' ', '');
      inputText = inputText.replace(/^0+(?!\.|$)/, ''); // Remove preceding 0, if any

      if (inputText && hourWithAmPm.test(inputText)) {
        return _this.formatHourWithAmPm(inputText);
      }
      if (inputText && hourWithoutAmPm.test(inputText)) {
        return _this.formatHourWithoutAmPm(inputText);
      }
      if (inputText && hoursWithAP.test(inputText)) {
        return _this.formatHoursWithAP(inputText);
      }
      if (inputText && hourAndMinutesWithAmPm.test(inputText)) {
        return _this.formatHourAndMinutesWithAmPm(inputText);
      }
      if (inputText && hoursAndMinutesWithoutAmPm.test(inputText)) {
        return _this.formatHoursAndMinutesWithoutAmPm(inputText);
      }
      if (inputText && hoursAndMinutesWithAP.test(inputText)) {
        return _this.formatHoursAndMinutesWithAP(inputText);
      }
      if (inputText && hoursAndMinutes.test(inputText)) {
        return _this.formatHoursAndMinutes(inputText);
      }
      if (inputText && hoursAndMiutesWithoutColonWithAP.test(inputText)) {
        return _this.formatHoursAndMiutesWithoutColonWithAP(inputText);
      }
      if (inputText && hoursAndMiutesWithoutColonWithAmPm.test(inputText)) {
        return _this.formatHoursAndMiutesWithoutColonWithAmPm(inputText);
      }
    };

    _this.formatHourWithAmPm = function (text) {
      return (text.slice(0, -2) + ':00 ' + text.slice(-2)).toUpperCase();
    };

    _this.formatHourWithoutAmPm = function (text) {
      var hours = Number(text);
      var ampm = _this.inferAmPmFromTime(hours);
      hours %= 12;
      hours = hours ? hours : 12; // hour '0' should be '12'
      return hours + ':00 ' + ampm;
    };

    _this.formatHoursWithAP = function (text) {
      var length = text.length;
      var ampm = text.slice(-1).toUpperCase() === 'A' ? 'AM' : 'PM';
      return (text.substring(0, length - 1) + ":00 " + ampm).toUpperCase();
    };

    _this.formatHourAndMinutesWithAmPm = function (text) {
      var length = text.length;
      return (text.substring(0, length - 2) + " " + text.substring(length - 2)).toUpperCase();
    };

    _this.formatHoursAndMinutesWithoutAmPm = function (text) {
      var splitText = text.split(':');
      var hours = splitText[0];
      var minutes = splitText[1];
      var ampm = _this.inferAmPmFromTime(hours);
      return hours + ":" + minutes + " " + ampm;
    };

    _this.formatHoursAndMinutesWithAP = function (text) {
      var ampm = text.slice(-1).toUpperCase() === 'A' ? 'AM' : 'PM';
      return (text.substring(0, text.length - 1) + ' ' + ampm).toUpperCase();
    };

    _this.formatHoursAndMinutes = function (text) {
      var hours = text.substring(0, text.length - 2);
      var minutes = text.slice(-2);
      var ampm = _this.inferAmPmFromTime(hours);
      return hours + ':' + minutes + ' ' + ampm;
    };

    _this.formatHoursAndMiutesWithoutColonWithAP = function (text) {
      var hours = text.substring(0, text.length - 3);
      var minutes = text.substring(0, text.length - 1).slice(-2);
      var ampm = text.slice(-1).toUpperCase() === 'A' ? ' AM' : ' PM';
      return hours + ':' + minutes + ampm;
    };

    _this.formatHoursAndMiutesWithoutColonWithAmPm = function (text) {
      var hours = text.substring(0, text.length - 4);
      var minutes = text.substring(0, text.length - 2).slice(-2);
      var ampm = text.slice(-2).toUpperCase() === 'AM' ? ' AM' : ' PM';
      return hours + ':' + minutes + ampm;
    };

    _this.inferAmPmFromTime = function (hours) {
      return hours <= 8 ? 'PM' : hours >= 12 ? 'PM' : 'AM';
    };

    _this.onOutsideClick = function () {
      // Check to ensure the timePicker has been interacted with
      if (!_this.state.showTimePicker) return;
      _this.onClearFocus();
    };

    _this.onTimeClick = function (time) {
      var blockedTimeSlots = _this.blockedTimeSlots;

      if (!(blockedTimeSlots && blockedTimeSlots.indexOf(time) !== -1)) {
        _this.setState({
          timeString: time,
          error: "",
          showTimePicker: false,
          warning: ''
        }, function () {
          _this.props.onChange(_this.createReturnedEvent(time), true);
        });
      }
    };

    _this.onClickToggleButton = function () {
      _this.setState(function (prevState) {
        return { showTimePicker: !prevState.showTimePicker };
      }, function () {
        _this.scrollToTimeSlot();
      });
    };

    _this.onFocus = function () {
      _this.setState({
        showTimePicker: true
      }, function () {
        _this.scrollToTimeSlot();
      });
    };

    _this.onClearFocus = function () {
      var timeString = _this.state.timeString;
      var selectedTime = _this.props.selectedTime;

      _this.didInteractWithField = true;

      var isValidTime = _this.isValidTimeString(timeString);
      var reformattedTimeString = isValidTime ? _this.formatTimeInput(timeString) : timeString;
      var valueIsSame = selectedTime === timeString || _this.getTimeString(selectedTime) === timeString;

      var warning = _this.state.warning && valueIsSame ? _this.state.warning : '';
      var error = warning ? '' : _this.getErrorMsg(reformattedTimeString);

      _this.setState({
        error: error,
        timeString: reformattedTimeString,
        showTimePicker: false,
        warning: warning
      });
    };

    _this.isTextFieldEmpty = function (textValue) {
      return textValue === "";
    };

    _this.isTextFieldValueValid = function (timeString) {
      var isEmpty = _this.isTextFieldEmpty(timeString);
      var isValidTime = _this.isValidTimeString(timeString);
      var isBlocked = _this.isTimeBlocked(_this.formatTimeInput(timeString));
      return isEmpty && !_this.props.required || isValidTime && !isBlocked;
    };

    _this.isTimeBlocked = function (formattedTime) {
      return _this.blockedTimeSlots.indexOf(formattedTime) !== -1;
    };

    _this.isValidTimeString = function (timeString) {
      var acceptedFormats = ['h', 'hA', 'h:', 'h A', 'hh:mm A', 'h:mmA', 'h:mm A', 'hh:mmA', 'h:mm', 'hmm', 'hmmA', 'hmm A'];
      return timeString && (0, _moment2.default)(timeString.trim(), acceptedFormats, true).isValid();
    };

    _this.getWarningMsg = function (time) {
      var overrideError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!_this.isTextFieldEmpty(time)) {
        if (!(0, _moment2.default)(time, 'h:mm A', true).isValid()) return 'Received an Invalid Time Format (hh:mm AM/PM)';
        if (_this.isTimeBlocked(time)) return 'Received a Blocked Time';
        return '';
      } else {
        if (overrideError && _this.props.required) return 'Received Empty Value on Required Field';
        return '';
      }
    };

    _this.getErrorMsg = function (time, passedTime) {
      if (!_this.didInteractWithField) return '';
      if (_this.props.error && _this.props.error.length > 0) return _this.props.error;
      if (_this.isTextFieldEmpty(time) && _this.props.required) return 'This Field is Required';
      if (_this.isTextFieldEmpty(time)) return '';
      if (!_this.isValidTimeString(time)) return 'Invalid Time or Time Format';
      if (_this.isTimeBlocked(time)) return 'Blocked Time Slot';
      return '';
    };

    _this.hasOnlyTimeCharacters = function (key) {
      // Allows accepted time characters
      var allowedFormat = /^[0-9]*[:]?[0-9]*[ ]?[a|A|p|P]?[m|M]?$/;
      // Allows non navigational keys
      var isNavigational = key.length > 1;
      return isNavigational || allowedFormat.test(key);
    };

    _this.onTextFieldChange = function (event) {
      var timeString = event.target.value;

      _this.setState({
        timeString: timeString,
        showTimePicker: false
      }, function () {
        // Unmounts and immediately Remounts TimePicker to align to textbox
        var timeString = _this.state.timeString;

        _this.props.onChange(_this.createReturnedEvent(timeString), _this.isTextFieldValueValid(timeString));
        setTimeout(_this.scrollToTimeSlot, 1);
        var error = _this.getErrorMsg(timeString);
        _this.setState({
          error: error,
          showTimePicker: error.length <= 0,
          warning: ''
        });
      });
    };

    _this.onTextFieldKeyDown = function (event) {
      var tabbedBlur = event.keyCode === 9;
      if (tabbedBlur) {
        _this.onClearFocus();
      } else if (event.ctrlKey || event.metaKey) {
        return;
      } else if (!_this.hasOnlyTimeCharacters(event.key)) {
        // Disallow any unaccepted characters to textfield
        event.preventDefault();
      }
    };

    _this.createReturnedEvent = function (time) {
      return {
        target: {
          name: _this.props.name,
          value: time
        }
      };
    };

    _this.buildTimePicker = function () {
      var timeSlotsArray = _this.timeSlotsArray;
      var htmlId = _this.props.htmlId;

      var scrollToTimeSlot = _this.getScrollToTimeSlot();
      return _react2.default.createElement(
        'ul',
        { id: htmlId + '-timeSlots', className: 'timeSlot-wrapper__style' },
        _this.getTimeSlotsArray(timeSlotsArray).map(function (timeSlot) {
          return _react2.default.createElement(_TimeSlot2.default, {
            className: _this.getTimeSlotClassName(timeSlot),
            timeSlot: timeSlot,
            ref: timeSlot === scrollToTimeSlot ? function (element) {
              _this.element = element;
            } : null,
            onClick: _this.onTimeClick,
            key: timeSlot

          });
        })
      );
    };

    var initialTimeString = _this.getTimeString(_this.props.selectedTime);
    _this.blockedTimeSlots = _this.validateArrayData(_this.props.blockedTimeSlots);
    _this.timeSlotsArray = _this.getTimeSlotsArray(_this.props.timeSlots);
    _this.didInteractWithField = _this.didInteractWithField();
    _this.state = {
      showTimePicker: false,
      error: _this.getErrorMsg(initialTimeString, _this.props.selectedTime),
      timeString: initialTimeString,
      warning: _this.getWarningMsg(initialTimeString, _this.props.selectedTime)
    };
    return _this;
  }

  _createClass(TimePicker, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      var timeUpdatedInternally = nextProps.selectedTime === this.props.selectedTime || nextProps.selectedTime === this.state.timeString;

      // If the field is not being interacted with, the time has changed externally and it's a valid time
      if (!timeUpdatedInternally) {
        var newPassedTime = this.getTimeString(nextProps.selectedTime);
        var warning = this.getWarningMsg(newPassedTime, true);
        var error = warning ? '' : this.getErrorMsg(newPassedTime, nextProps.selectedTime);

        this.setState({
          error: error,
          timeString: newPassedTime,
          warning: warning
        }, function () {
          _this2.props.onChange(_this2.createReturnedEvent(newPassedTime), !error);
        });
      }
    }

    // Time Slot Functions


    // Formatting functions


    // Behavioral functions


    // Text Field methods


    // function needed to catch keystroke for tabbed blur and blocking unallowed characters.


    // this function mocks the returned event

  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          className = _props.className,
          displayLabel = _props.displayLabel,
          htmlId = _props.htmlId,
          label = _props.label,
          required = _props.required,
          name = _props.name,
          placeholder = _props.placeholder;
      var _state = this.state,
          error = _state.error,
          showTimePicker = _state.showTimePicker,
          timeString = _state.timeString,
          warning = _state.warning;

      var timePicker = this.buildTimePicker();
      // const isError = error.length > 0;
      // const isWarning = warning && warning.length > 0;
      var isError = !!error;
      var isWarning = !!warning && !isError;

      return _react2.default.createElement(
        'div',
        { id: htmlId, className: "TimePicker " + className },
        _react2.default.createElement(
          _OutsideClickHandler2.default,
          { onOutsideClick: this.onOutsideClick },
          _react2.default.createElement(
            _FormGroup2.default,
            {
              controlId: 'timePickerTextField',
              className: 'timePickerTextField__formGroup',
              validationState: isError ? 'error' : isWarning ? 'warning' : null
            },
            ' ',
            displayLabel && _react2.default.createElement(
              _Label2.default,
              {
                className: className,
                required: required,
                htmlId: htmlId + '-label'
              },
              label
            ),
            _react2.default.createElement(
              _InputGroup2.default,
              {
                onKeyDown: this.onTextFieldKeyDown
              },
              _react2.default.createElement(_FormControl2.default, {
                name: name,
                onChange: this.onTextFieldChange,
                onClick: this.onFocus,
                onFocus: this.onFocus,
                placeholder: placeholder,
                type: 'text',
                value: timeString
              }),
              _react2.default.createElement(
                _InputGroup2.default.Button,
                null,
                _react2.default.createElement(
                  _Button2.default,
                  {
                    htmlId: htmlId + '-toggleButton',
                    onClick: this.onClickToggleButton,
                    className: "TimePicker__trigger-button",
                    buttonStyle: error ? "danger" : "default" },
                  _react2.default.createElement(_IconAccessTime2.default, null)
                )
              )
            ),
            isError ? _react2.default.createElement(
              _HelpBlock2.default,
              null,
              error
            ) : isWarning ? _react2.default.createElement(
              _HelpBlock2.default,
              null,
              warning
            ) : null
          ),
          showTimePicker && timePicker
        )
      );
    }
  }]);

  return TimePicker;
}(_react.Component);

exports.default = TimePicker;


TimePicker.propTypes = {
  /** Array of time slots that should be shown as blocked, thus disabling the selection. <br/>
   * Example: <code>['9:00 AM', '9:50 AM', '12:25 PM']</code> */
  blockedTimeSlots: _propTypes2.default.array,

  /** CSS className given to TimePicker. */
  className: _propTypes2.default.string,

  /** Displays label if set to true. */
  displayLabel: _propTypes2.default.bool,

  /** String to display when error occurs. */
  error: _propTypes2.default.string,

  /** Globally unique and descriptive HTML ID. Used by QA for automated testing. */
  htmlId: _propTypes2.default.string.isRequired,

  /** Form input label. */
  label: _propTypes2.default.string.isRequired,

  /** Input name. */
  name: _propTypes2.default.string.isRequired,

  /** onChange callback. Called with <code>cb(event, isValid)</code>. Check isValid to determine if the control is in error. */
  onChange: _propTypes2.default.func.isRequired,

  /** Placeholder for text input. */
  placeholder: _propTypes2.default.string.isRequired,

  /** Mark field as required and validate on blur if true. */
  required: _propTypes2.default.bool,

  /** Accepts date in ISO 8601 format (UTC with offset) or shorthand "HH:MM AM/PM" format.<br/>
  * <ul>
    *  <li> Example ISO 8601: <code>2017-04-20 13:42:25-0500</code> </li>
    *  <li> Example shorthand: <code>08:00 PM</code></li>
  * </ul>
  */
  selectedTime: _propTypes2.default.string.isRequired,

  /** Interval or an array of timeSlots.
   * <p>Specify an interval in minutes to automatically populate a list of time slots.<br/>
   * Example: <code>40</code><br/>
   * The setting above will generate a list of time slots at 40 minute increments (12:00 AM, 12:40 AM, etc).</p>
   * <p>Or, instead of an interval, you can specify an explicit array of time slots:<br/>
   * Example: <code>['9:00 AM', '9:35 AM', '12:10 PM']</code></p> */
  timeSlots: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.array])
};

TimePicker.defaultProps = {
  displayLabel: true,
  timeSlots: 30
};