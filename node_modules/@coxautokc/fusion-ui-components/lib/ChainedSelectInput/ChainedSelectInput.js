'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _SelectInput = require('../SelectInput');

var _SelectInput2 = _interopRequireDefault(_SelectInput);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Bundles a series of SelectInputs that work together. Once one option is selected,
 * a function will be called to retrieve the corresponding values for the next Input.
 * Enabling and disabling of the remaining inputs is handled automatically.
 */
var ChainedSelectInput = function (_React$Component) {
  _inherits(ChainedSelectInput, _React$Component);

  function ChainedSelectInput(props) {
    _classCallCheck(this, ChainedSelectInput);

    var _this = _possibleConstructorReturn(this, (ChainedSelectInput.__proto__ || Object.getPrototypeOf(ChainedSelectInput)).call(this, props));

    _this.getItemIndex = function (items, name) {
      return items.findIndex(function (element, index) {
        return element.name === name;
      });
    };

    _this.onChange = function (event, valid) {
      // copy values and items
      var value = Object.assign({}, _this.state.value);
      // makes array copy
      var items = _this.state.items.slice();

      // set the value of the select box to what was selected
      value[event.target.name] = event.target.value;

      var index = _this.getItemIndex(items, event.target.name);
      // If the current item is set to empty, reset it to the active item.
      if (event.target.value === '') {
        return _this.setState({ activeItem: index, value: value });
      }

      // If we are at the end of the list... Call props.onChange
      if (index === items.length - 1) {
        _this.setState({ activeItem: index, value: value });
        _this.props.onChange(value);
      } else {
        // Otherwise get the list for the next box.
        // set next select box to loading
        items[index + 1].loading = true;

        // clear all other options below...
        for (var i = index + 1; i < items.length; i++) {
          value[items[i].name] = '';
        }

        // update state
        _this.setState({ activeItem: index + 1, value: value });
        _this.props.items[index + 1].getOptions(value, function (options) {
          var items = Object.assign(_this.state.items);
          items[index + 1].options = options;
          items[index + 1].loading = false;
          _this.setState({ items: items });
        });
      }
    };

    _this.state = {
      error: _this.props.error || '',
      activeItem: _this.getActiveIndex(_this.props.items, _this.props.value),
      value: props.value,
      items: props.items
    };
    return _this;
  }

  _createClass(ChainedSelectInput, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var value = nextProps.value,
          items = nextProps.items;

      var activeItem = this.getActiveIndex(items, value);
      this.setState({ value: value, items: items, activeItem: activeItem });
    }
  }, {
    key: 'getActiveIndex',
    value: function getActiveIndex(items, value) {
      var activeItem = items.findIndex(function (item, index) {
        return !value[item.name];
      });

      return activeItem !== -1 ? activeItem : items.length - 1;
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          htmlId = _props.htmlId,
          className = _props.className;
      var _state = this.state,
          items = _state.items,
          value = _state.value;


      return _react2.default.createElement(
        'div',
        null,
        items.map(function (item, index) {
          return _react2.default.createElement(_SelectInput2.default, {
            error: item.error,
            key: item.label,
            className: className,
            disabled: index > _this2.state.activeItem || item.loading,
            placeholder: item.loading ? 'Loading...' : '',
            htmlId: htmlId + '-' + item.name,
            name: item.name,
            label: item.label,
            onChange: _this2.onChange,
            value: value ? value[item.name] : '',
            options: item.options
          });
        })
      );
    }
  }]);

  return ChainedSelectInput;
}(_react2.default.Component);

ChainedSelectInput.propTypes = {
  /** Appended to the FormGroup. */
  className: _propTypes2.default.string,

  /** String to display when error occurs. */
  error: _propTypes2.default.string,

  /** Globally unique, descriptive ID. Used for automated testing.
   * Will append -label on to each select in the chain.
   * */
  htmlId: _propTypes2.default.string.isRequired,

  /** An array of settings for each of the SelectInputs including Label, Name, Options, and a function that will be
   * called to get options based on a value. The function signature: (value, callback) {}
   * The callback will accept an array of options.
   * Eg: <pre><code>items: [
        {
          label: 'Year',
          name: 'year',
          options: [{ value: '2017', label: '2017' }, { value: '2016', label: '2016' }],
        }, {
          label: 'Make',
          name: 'make',
          options: [{ value: 'ford', label: 'Ford' }, { value: 'honda', label: 'Honda' }],
          getOptions: this.getMakes
        }, {
          label: 'Model',
          name: 'model',
          options: [],
          getOptions: this.getModels
        }
      ]</code></pre>
   */
  items: _propTypes2.default.array.isRequired,

  /** onChange callback. Called with <code>cb(event)</code>. Called once all select boxes are selected.*/
  onChange: _propTypes2.default.func.isRequired,

  /** Perform validation on blur and mark field as required with asterisk if true. */
  required: _propTypes2.default.bool,

  /** An object that describes the value of the collection of inputs. Example: <code>{label: value, label:value}</code> */
  value: _propTypes2.default.object

};

exports.default = ChainedSelectInput;